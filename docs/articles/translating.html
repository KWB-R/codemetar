<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Translating between schema using JSON-LD • codemetar</title>
<!-- jquery --><script src="https://code.jquery.com/jquery-3.1.0.min.js" integrity="sha384-nrOSfDHtoPMzJHjVTdCopGqIqeYETSXhZDFyniQ8ZHcVy08QesyHcnOUpMpqnmWq" crossorigin="anonymous"></script><!-- Bootstrap --><link href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous">
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script><!-- Font Awesome icons --><link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" integrity="sha384-T8Gy5hrqNKT+hzMclPo118YTQO6cYprQmhrYwIiQ/3axmI1hQomh7Ud2hPOy8SP1" crossorigin="anonymous">
<!-- pkgdown --><link href="../pkgdown.css" rel="stylesheet">
<script src="../jquery.sticky-kit.min.js"></script><script src="../pkgdown.js"></script><!-- mathjax --><script src="https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><!--[if lt IE 9]>
<script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
<script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
<![endif]-->
</head>
<body>
    <div class="container template-vignette">
      <header><div class="navbar navbar-default navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="../index.html">codemetar</a>
    </div>
    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
<li>
  <a href="../reference/index.html">Reference</a>
</li>
<li>
  <a href="../articles/index.html">Articles</a>
</li>
      </ul>
<ul class="nav navbar-nav navbar-right">
<li>
  <a href="https://github.com/codemeta/codemetar">
    <span class="fa fa-github fa-lg"></span>
     
  </a>
</li>
      </ul>
</div>
<!--/.nav-collapse -->
  </div>
<!--/.container -->
</div>
<!--/.navbar -->

      
      </header><div class="row">
  <div class="col-md-9">
    <div class="page-header toc-ignore">
      <h1>Translating between schema using JSON-LD</h1>
                        <h4 class="author">Carl Boettiger</h4>
            
            <h4 class="date">2017-05-17</h4>
          </div>

    
    
<div class="contents">
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(<span class="st">"codemetar"</span>)
<span class="kw">library</span>(<span class="st">"tidyverse"</span>)
<span class="kw">library</span>(<span class="st">"jsonlite"</span>)
<span class="kw">library</span>(<span class="st">"jsonld"</span>)
<span class="kw">library</span>(<span class="st">"httr"</span>)</code></pre></div>
<p>One of the central motivations of JSON-LD is making it easy to translate between different representations of what are fundamentally the same data types. Doing so uses the two core algorithms of JSON-LD: <em>expansion</em> and <em>compaction</em>, as <a href="https://www.youtube.com/watch?v=Tm3fD89dqRE">this excellent short video by JSON-LD creator Manu Sporny</a> describes.</p>
<p>Here’s how we would use JSON-LD (from R) to translate between the two examples of JSON data from different providers as shown in the video. First, the JSON from the original provider:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">ex &lt;-
<span class="st">'{</span>
<span class="st">"@context":{</span>
<span class="st">  "shouter": "http://schema.org/name",</span>
<span class="st">  "txt": "http://schema.org/commentText"</span>
<span class="st">},</span>
<span class="st">"shouter": "Jim",</span>
<span class="st">"txt": "Hello World!"</span>
<span class="st">}'</span></code></pre></div>
<p>Next, we need the context of the second data provider. This will let us translate the JSON format used by provider one (“Shouttr”) to the second (“BigHash”):</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">bighash_context &lt;-<span class="st"> </span>
<span class="st">'{</span>
<span class="st">"@context":{</span>
<span class="st">  "user": "http://schema.org/name",</span>
<span class="st">  "comment": "http://schema.org/commentText"</span>
<span class="st">}</span>
<span class="st">}'</span></code></pre></div>
<p>With this in place, we simply expand the original JSON and then compact using the new context:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">jsonld_expand</span>(ex) %&gt;%
<span class="st">  </span><span class="kw">jsonld_compact</span>(<span class="dt">context =</span> bighash_context)</code></pre></div>
<pre><code>{
  "@context": {
    "user": "http://schema.org/name",
    "comment": "http://schema.org/commentText"
  },
  "comment": "Hello World!",
  "user": "Jim"
} </code></pre>
<div id="crosswalk-contexts" class="section level2">
<h2 class="hasAnchor">
<a href="#crosswalk-contexts" class="anchor"></a>Crosswalk contexts</h2>
<p>The CodeMeta Crosswalk table seeks to accomplish a very similar goal. The crosswalk table provides a human-readable mapping of different software metadata providers into the codemeta context (an extension of schema.org).</p>
<p>We’ll start with the actual crosswalk table itself:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">crosswalk &lt;-<span class="st"> "https://github.com/codemeta/codemeta/raw/master/crosswalk.csv"</span>
cw &lt;-<span class="st"> </span><span class="kw">read_csv</span>(crosswalk)</code></pre></div>
</div>
<div id="datacite" class="section level2">
<h2 class="hasAnchor">
<a href="#datacite" class="anchor"></a>DataCite</h2>
<p>We can illustrate using the expansion and compaction process to crosswalk DataCite’s metadata schema into other formats, such as the native codemeta format or the Zenodo format. First, let’s start with some DataCite metadata:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">datacite_ex &lt;-<span class="st"> "https://raw.githubusercontent.com/codemeta/codemetar/master/inst/examples/datacite-xml.json"</span>
<span class="kw">cat</span>(<span class="kw">readLines</span>(datacite_ex), <span class="dt">sep=</span><span class="st">"</span><span class="ch">\n</span><span class="st">"</span>)</code></pre></div>
<pre><code>{
  "identifier": "10.5281/zenodo.573741",
  "creators": [
    { "givenName": "Jouni",
      "familyName": "Helske"
    },
    {
      "givenName": "Matti",
      "familyName": "Vihola"
    }
  ],
  "title": "Bayesian Inference Of State Space Models With The Bssm Package",
  "publisher": "Zenodo",
  "publicationYear": "2017",
  "resourceType": "Software",
  "date": "2017-05-10",
  "rights": "Open Access",
  "description": [
      "Efficient methods for Bayesian inference of state space models via particle Markov chain Monte Carlo and importance sampling type corrected Markov chain Monte Carlo. Currently supports models with Gaussian, Poisson, binomial, or negative binomial observation densities and Gaussian state dynamics, as well as general non-linear Gaussian models.",
      "Funded by Academy of Finland grant 284513, \"Exact approximate Monte Carlo methods for complex Bayesian inference\"."
  ]
}</code></pre>
<p>Note this example uses a JSON-ified representation of DataCite’s internal schema, which is XML-based. So far, this is just plain JSON, with no context. We will use the crosswalk table to define the DataCite context with reference to codemeta:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">## read the file
datacite_list &lt;-<span class="st"> </span><span class="kw">read_json</span>(datacite_ex)

## add context using the codemeta crosswalk function on the current crosswalk table
datacite_list$<span class="st">`</span><span class="dt">@context</span><span class="st">`</span> &lt;-<span class="st"> </span>codemetar::<span class="kw"><a href="../reference/crosswalk.html">crosswalk</a></span>(<span class="st">"DataCite"</span>, cw)

## serialize as JSON
datacite_json &lt;-
datacite_list %&gt;%<span class="st"> </span>
<span class="st">  </span><span class="kw">toJSON</span>(<span class="dt">auto_unbox=</span><span class="ot">TRUE</span>, <span class="dt">pretty=</span><span class="ot">TRUE</span>)</code></pre></div>
<p>We can now expand this json in terms of DataCite context we just derived from the table, and then compact it into the CodeMeta native context:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">datacite_cm &lt;-
<span class="st">  </span><span class="kw">jsonld_expand</span>(datacite_json) %&gt;%<span class="st"> </span>
<span class="st">  </span><span class="kw">jsonld_compact</span>(<span class="dt">context =</span> <span class="st">"https://raw.githubusercontent.com/codemeta/codemeta/master/codemeta-v2.jsonld"</span>) 
datacite_cm</code></pre></div>
<pre><code>{
  "@context": "https://raw.githubusercontent.com/codemeta/codemeta/master/codemeta-v2.jsonld",
  "author": [
    {
      "familyName": "Helske",
      "givenName": "Jouni"
    },
    {
      "familyName": "Vihola",
      "givenName": "Matti"
    }
  ],
  "dateCreated": "2017-05-10",
  "datePublished": "2017",
  "description": [
    "Efficient methods for Bayesian inference of state space models via particle Markov chain Monte Carlo and importance sampling type corrected Markov chain Monte Carlo. Currently supports models with Gaussian, Poisson, binomial, or negative binomial observation densities and Gaussian state dynamics, as well as general non-linear Gaussian models.",
    "Funded by Academy of Finland grant 284513, \"Exact approximate Monte Carlo methods for complex Bayesian inference\"."
  ],
  "identifier": "10.5281/zenodo.573741",
  "license": "Open Access",
  "publisher": "Zenodo"
} </code></pre>
<p>The result should be a valid <code>codemeta.json</code> document.</p>
</div>
<div id="comparison-to-native-schema-org-translation" class="section level2">
<h2 class="hasAnchor">
<a href="#comparison-to-native-schema-org-translation" class="anchor"></a>Comparison to native schema.org translation:</h2>
<p>DataCite actually returns data directly in JSON-LD format using exclusively the schema.org context. We can query that data directly:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(<span class="st">"httr"</span>)
resp &lt;-<span class="st"> </span><span class="kw">GET</span>(<span class="st">"https://doi.org/10.5281/zenodo.573741"</span>, <span class="kw">add_headers</span>(<span class="dt">Accept=</span><span class="st">"application/vnd.schemaorg.ld+json"</span>))
datacite_jsonld &lt;-<span class="st"> </span><span class="kw">content</span>(resp, <span class="dt">type=</span><span class="st">"application/json"</span>)</code></pre></div>
<p>This time we have no need to invoke the crosswalk context, since the data is already in schema.org context (which codemeta also uses):</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">datacite_cm &lt;-<span class="st"> </span>
<span class="st">  </span>datacite_jsonld %&gt;%<span class="st"> </span>
<span class="st">  </span><span class="kw">toJSON</span>(<span class="dt">pretty =</span> <span class="ot">TRUE</span>, <span class="dt">auto_unbox =</span> <span class="ot">TRUE</span>) %&gt;%
<span class="st">  </span><span class="kw">jsonld_expand</span>() %&gt;%<span class="st"> </span>
<span class="st">  </span><span class="kw">jsonld_compact</span>(<span class="dt">context =</span> <span class="st">"https://raw.githubusercontent.com/codemeta/codemeta/master/codemeta-v2.jsonld"</span>) 

datacite_cm</code></pre></div>
<pre><code>{
  "@context": "https://raw.githubusercontent.com/codemeta/codemeta/master/codemeta-v2.jsonld",
  "@id": "https://doi.org/10.5281/zenodo.573741",
  "@type": "SoftwareSourceCode",
  "schema:additionalType": {
    "@id": "Software"
  },
  "author": [
    {
      "@type": "Person",
      "familyName": "Helske",
      "givenName": "Jouni",
      "name": "Jouni Helske"
    },
    {
      "@type": "Person",
      "familyName": "Vihola",
      "givenName": "Matti",
      "name": "Matti Vihola"
    }
  ],
  "datePublished": {
    "@type": "schema:Date",
    "@value": "2017-05-10"
  },
  "description": [
    "Efficient methods for Bayesian inference of state space models via particle Markov chain Monte Carlo and importance sampling type corrected Markov chain Monte Carlo. Currently supports models with Gaussian, Poisson, binomial, or negative binomial observation densities and Gaussian state dynamics, as well as general non-linear Gaussian models.",
    "Funded by Academy of Finland grant 284513, \"Exact approximate Monte Carlo methods for complex Bayesian inference\"."
  ],
  "name": "Bayesian Inference Of State Space Models With The Bssm Package",
  "provider": {
    "@type": "Organization",
    "name": "DataCite"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Zenodo"
  },
  "schema:schemaVersion": {
    "@id": "http://datacite.org/schema/kernel-3"
  }
} </code></pre>
<p>This is very close to the codemeta document we got by translating the DataCite XML using the crosswalk table.</p>
</div>
<div id="transforming-into-other-column-schema" class="section level2">
<h2 class="hasAnchor">
<a href="#transforming-into-other-column-schema" class="anchor"></a>Transforming into other column schema</h2>
<p>Note that we can also use this approach to crosswalk into another standard by compacting into the context for the given column. For instance, here we translate our datacite record into a zenodo record. First we get the context from the crosswalk:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">zenodo_context &lt;-<span class="st"> </span>
<span class="st">  </span><span class="kw">list</span>(<span class="st">"@context"</span> =<span class="st"> </span><span class="kw"><a href="../reference/crosswalk.html">crosswalk</a></span>(<span class="st">"Zenodo"</span>, cw)) %&gt;%<span class="st"> </span>
<span class="st">  </span><span class="kw">toJSON</span>(<span class="dt">pretty =</span> <span class="ot">TRUE</span>, <span class="dt">auto_unbox =</span> <span class="ot">TRUE</span>)</code></pre></div>
<p>then apply it as before:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">  <span class="kw">jsonld_expand</span>(datacite_cm) %&gt;%<span class="st"> </span>
<span class="st">  </span><span class="kw">jsonld_compact</span>(<span class="dt">context =</span> zenodo_context) </code></pre></div>
<pre><code>{
  "@context": {
    "schema": "http://schema.org/",
    "codemeta": "https://codemeta.github.io/terms/",
    "relatedLink": "schema:codeRepository",
    "communities": "schema:applicationCategory",
    "creators": "schema:author",
    "date_published": "schema:datePublished",
    "contributors": "schema:funder",
    "keywords": "schema:keywords",
    "license": "schema:license",
    "description": "schema:description",
    "id": "schema:identifier",
    "title": "schema:name",
    "affiliation": "schema:affiliation",
    "ORCID": "schema:identifier",
    "name": "schema:name"
  },
  "@id": "https://doi.org/10.5281/zenodo.573741",
  "@type": "schema:SoftwareSourceCode",
  "schema:additionalType": {
    "@id": "Software"
  },
  "creators": [
    {
      "@type": "schema:Person",
      "schema:familyName": "Helske",
      "schema:givenName": "Jouni",
      "name": "Jouni Helske"
    },
    {
      "@type": "schema:Person",
      "schema:familyName": "Vihola",
      "schema:givenName": "Matti",
      "name": "Matti Vihola"
    }
  ],
  "date_published": {
    "@type": "schema:Date",
    "@value": "2017-05-10"
  },
  "description": [
    "Efficient methods for Bayesian inference of state space models via particle Markov chain Monte Carlo and importance sampling type corrected Markov chain Monte Carlo. Currently supports models with Gaussian, Poisson, binomial, or negative binomial observation densities and Gaussian state dynamics, as well as general non-linear Gaussian models.",
    "Funded by Academy of Finland grant 284513, \"Exact approximate Monte Carlo methods for complex Bayesian inference\"."
  ],
  "name": "Bayesian Inference Of State Space Models With The Bssm Package",
  "schema:provider": {
    "@type": "schema:Organization",
    "name": "DataCite"
  },
  "schema:publisher": {
    "@type": "schema:Organization",
    "name": "Zenodo"
  },
  "schema:schemaVersion": {
    "@id": "http://datacite.org/schema/kernel-3"
  }
} </code></pre>
<p>This data should be now use valid Zenodo terms (e.g. using <code>creators</code> for <code>schema:author</code>). Note that we also see explicitly the context that <code>codemeta::crosswalk</code> produced as <code>zenodo_context</code>, since we passed this information as a json file and not a URL. This provides a nice illustration of what the crosswalk is returning when asked for a context of a given column.</p>
<p>Note that data that many of the fields could not be directly crosswalked into Zenodo terms, because (at least according to the crosswalk table) they have no analog in Zenodo, such as <code>schema:dateCreated</code>. Instead of dropping this data, the JSON-LD has retained the information using the original prefix <code>schema:</code>, indicating that the term is part of the <code>schema.org</code> context but not recognized in the context of Zenodo.</p>
<p>Note this also happens if properties do not have a 1:1 map, since JSON-LD doesn’t provide a convenient way to map two separate properties like <code>givenName</code>, <code>familyName</code> into a single property, <code>name</code> either. JSON-LD will also refuse to map a term that has a potentially different type in the new context (since type coercion can also lead to data loss). In this way, compaction is very conservative.</p>
</div>
<div id="codemeta" class="section level2">
<h2 class="hasAnchor">
<a href="#codemeta" class="anchor"></a>Codemeta</h2>
<p>We can use a similar crosswalk strategy to translate from a JSON-LD file writing using v1 of the codemeta context into the current, v2 context:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">codemetav1 &lt;-<span class="st"> </span><span class="kw"><a href="../reference/crosswalk.html">crosswalk</a></span>(<span class="st">"codemeta-V1"</span>, cw)

## Add some altered Type definitions from v1
codemetav1 &lt;-<span class="st"> </span><span class="kw">c</span>(codemetav1,
                    <span class="dt">person =</span> <span class="st">"schema:Person"</span>,
                    <span class="dt">organization =</span> <span class="st">"schema:Organization"</span>,
                    <span class="dt">SoftwareSoureCode =</span> <span class="st">"schema:SoftwareSourceCode"</span>)</code></pre></div>
<p>To crosswalk a vocabulary, we must use the context the CrossWalk table defines for that vocabulary. Most vocabularies are not already ontologies with their own base URLs, in which case this is relatively intuitive. But we also need to use the CrossWalk context even when the data originates in another context (SoftwareOntology, DOAP, codemeta-v1), since otherwise those terms will stay in their original space (e.g <code>dcterms:identifer</code> will remain a different kind of property from a <code>schema:identifer</code>, etc)</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">v1 &lt;-<span class="st"> "https://raw.githubusercontent.com/codemeta/codemetar/master/inst/examples/codemeta-v1.json"</span>
<span class="co">#v1 &lt;- "../examples/codemeta-v1.json" ## or local path</span>
v1_obj &lt;-<span class="st"> </span>jsonlite::<span class="kw">read_json</span>(v1)
v1_obj$<span class="st">`</span><span class="dt">@context</span><span class="st">`</span> &lt;-<span class="st"> </span>codemetav1
v1_json &lt;-<span class="st"> </span><span class="kw">toJSON</span>(v1_obj, <span class="dt">pretty=</span><span class="ot">TRUE</span>, <span class="dt">auto_unbox =</span> <span class="ot">TRUE</span>)

<span class="co">#write_json(v1_obj, "v1.json", pretty=TRUE, auto_unbox = TRUE)</span></code></pre></div>
<p>With a JSON object in place, along with a context file that defines how that vocabulary is expressed in the context of <code>schema.org</code> / <code>codemeta</code>, we can now perform the exansion and compaction routine as before. Expansion uses the native context from the file, compaction uses the new context of codemeta terms.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">v2_json &lt;-<span class="st"> </span>
<span class="kw">jsonld_expand</span>(v1_json) %&gt;%
<span class="st">  </span><span class="kw">jsonld_compact</span>(<span class="dt">context =</span> <span class="st">"https://raw.githubusercontent.com/codemeta/codemeta/master/codemeta-v2.jsonld"</span>) 
v2_json</code></pre></div>
<pre><code>{
  "@context": "https://raw.githubusercontent.com/codemeta/codemeta/master/codemeta-v2.jsonld",
  "@type": "SoftwareSourceCode",
  "author": [
    {
      "@id": "http://orcid.org/0000-0002-2192-403X",
      "@type": "Person",
      "affiliation": "NCEAS",
      "email": "slaughter@nceas.ucsb.edu",
      "name": "Peter Slaughter"
    },
    {
      "@id": "http://orcid.org/0000-0002-3957-2474",
      "@type": "Organization",
      "email": "info@ucop.edu",
      "name": "University of California, Santa Barbara"
    }
  ],
  "citation": "https://github.com/codemeta/codemeta-paper",
  "codeRepository": "https://github.com/codemeta/codemeta",
  "dateModified": "2014-08-15",
  "datePublished": "2014-09-06",
  "description": "Codemeta is a metadata content standard for software.  It includes schemas in JSON-LD and XML Schema for providing semantics and validation.",
  "downloadUrl": "https://github.com/codemeta/codemeta/releases/codemeta_2.1.0-rc.2.tar.gz",
  "identifier": "http://dx.doi.org/10.6084/m9.figshare.828487",
  "keywords": [
    "software",
    "metadata"
  ],
  "license": "Apache-2.0",
  "name": "codemeta",
  "programmingLanguage": {
    "name": "ruby",
    "url": "https://www.ruby-lang.org/en/",
    "version": "2.3.1"
  },
  "publisher": "figshare",
  "schema:softwareRequirements": [
    {
      "identifier": "http://doi.org/10.xxxx/A324566",
      "name": "export_fig",
      "version": "1.99"
    },
    {
      "identifier": "89766228838383883",
      "name": "npplus",
      "operatingSystem": [
        "MacOS",
        "Linux"
      ],
      "version": "0.9.4"
    },
    {
      "identifier": "7777575757757-389349843-90898",
      "name": "popbio",
      "operatingSystem": [
        "Windows",
        "OS X Mavericks"
      ],
      "version": "1.3.4"
    }
  ],
  "version": "2.1.0-rc.2",
  "buildInstructions": "https://github.com/codemeta/codemeta/buildInstructions",
  "contIntegration": "https://github.com/codemeta/codemeta/minitest",
  "developmentStatus": "active",
  "embargoDate": "2014-08-06T10:00:01Z",
  "funding": "National Science Foundation grant #012345678",
  "issueTracker": "https://github.com/codemeta/codemeta/issues",
  "codemeta:maintainer": {
    "@id": "http://orcid.org/0000-0002-2192-403X",
    "@type": "Person",
    "email": "slaughter@nceas.ucsb.edu",
    "name": "Peter Slaughter"
  },
  "readme": "https://github.com/codemeta/codemeta/README.md",
  "referencePublication": [
    "DOI:10.1177/0165551504045850",
    "DOI:10.1145/2815833.2816955"
  ],
  "codemeta:suggests": {
    "name": "tokenizertools",
    "operatingSystem": [
      "MacOS",
      "Linux"
    ],
    "version": "1.0"
  }
} </code></pre>
<p>Note that certain terms in the <code>codemeta</code> namespace are explicitly being typed as such (e.g. <code>codemeta:maintainer</code> rather than plain <code>maintainer</code>) by the compaction algorithm, because these terms do not have matching types in their original codemeta v1 context vs codemeta v2 context.</p>
</div>
<div id="framing" class="section level2">
<h2 class="hasAnchor">
<a href="#framing" class="anchor"></a>Framing</h2>
<p>We can use a frame to extract particular elements in a particular format. This is most useful when there are highly nested complex types. Framing with the <code>@explicit</code> tag is also a good way to filter out fields that we are not interested in, though these are usually less problematic for developers to work around.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">frame &lt;-<span class="st"> </span>
<span class="st">'{</span>
<span class="st">  "@context":"https://raw.githubusercontent.com/codemeta/codemeta/master/codemeta-v2.jsonld",</span>
<span class="st">  "@type": "SoftwareSourceCode",</span>
<span class="st">  "@explicit": "true",</span>
<span class="st">  "readme": {},</span>
<span class="st">  "description": {},</span>
<span class="st">  "maintainer": {}</span>
<span class="st">}'</span>

<span class="kw">jsonld_frame</span>(v2_json, frame)</code></pre></div>
<pre><code>{
  "@context": "https://raw.githubusercontent.com/codemeta/codemeta/master/codemeta-v2.jsonld",
  "@graph": [
    {
      "@id": "_:b0",
      "@type": "SoftwareSourceCode",
      "description": "Codemeta is a metadata content standard for software.  It includes schemas in JSON-LD and XML Schema for providing semantics and validation.",
      "codemeta:maintainer": {
        "@id": "http://orcid.org/0000-0002-2192-403X",
        "@type": "Person",
        "affiliation": "NCEAS",
        "email": "slaughter@nceas.ucsb.edu",
        "name": "Peter Slaughter"
      },
      "readme": "https://github.com/codemeta/codemeta/README.md"
    }
  ]
} </code></pre>
<p>Note that our frame can refer to <code>maintainer</code> even though the compaction has left the Property as <code>codemeta:maintainer</code>.</p>
</div>
</div>
  </div>

  <div class="col-md-3 hidden-xs hidden-sm" id="sidebar">
        <div id="tocnav">
      <h2>Contents</h2>
      <ul class="nav nav-pills nav-stacked">
<li><a href="#crosswalk-contexts">Crosswalk contexts</a></li>
      <li><a href="#datacite">DataCite</a></li>
      <li><a href="#comparison-to-native-schema.org-translation">Comparison to native schema.org translation:</a></li>
      <li><a href="#transforming-into-other-column-schema">Transforming into other column schema</a></li>
      <li><a href="#codemeta">Codemeta</a></li>
      <li><a href="#framing">Framing</a></li>
      </ul>
</div>
      </div>

</div>


      <footer><div class="copyright">
  <p>Developed by Carl Boettiger.</p>
</div>

<div class="pkgdown">
  <p>Site built with <a href="http://hadley.github.io/pkgdown/">pkgdown</a>.</p>
</div>

      </footer>
</div>

  </body>
</html>
