---
title: "Translating between schema using JSON-LD"
author: "Carl Boettiger"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Translating between schema using JSON LD}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---



```{r include=FALSE}
knitr::opts_chunk$set(comment="")
```

```{r message=FALSE}
library("codemetar")
library("magrittr")
library("jsonlite")
library("jsonld")
library("httr")
library("readr")
```

## JSON-LD transforms: Expansion and Compaction

One of the central motivations of JSON-LD is making it easy to translate between different representations of what are fundamentally the same data types. Doing so uses the two core algorithms of JSON-LD: *expansion* and *compaction*, as [this excellent short video by JSON-LD creator Manu Sporny](https://www.youtube.com/watch?v=Tm3fD89dqRE) describes.

Here's how we would use JSON-LD (from R) to translate between the two examples of JSON data from different providers as shown in the video.  First, the JSON from the original provider:

```{r}
ex <-
'{
"@context":{
  "shouter": "http://schema.org/name",
  "txt": "http://schema.org/commentText"
},
"shouter": "Jim",
"txt": "Hello World!"
}'
```

Next, we need the context of the second data provider.  This will let us translate the JSON format used by provider one ("Shouttr") to the second ("BigHash"):

```{r}
bighash_context <- 
'{
"@context":{
  "user": "http://schema.org/name",
  "comment": "http://schema.org/commentText"
}
}'
```

With this in place, we simply expand the original JSON and then compact using the new context:

```{r}
jsonld_expand(ex) %>%
  jsonld_compact(context = bighash_context)
```

## Crosswalking

The CodeMeta Crosswalk table seeks to accomplish a very similar goal.  The crosswalk table provides a human-readable mapping of different software metadata providers into the codemeta context (an extension of schema.org).  For instance, we'll read in some data from GitHub:


### GitHub

```{r}
r <- gh::gh("/repos/:owner/:repo", owner = "ropensci", repo = "EML")
github_meta <- crosswalk(r, "GitHub")
github_meta
```



## Transforming into other column schema



```{r}
crosswalk(r, "Zenodo", "GitHub") %>%
drop_context()
```



## DataCite


We can illustrate using the expansion and compaction process to crosswalk DataCite's metadata schema into other formats, such as the native codemeta format or the Zenodo format.  First, let's start with some DataCite metadata:


```{r include=FALSE, eval=FALSE}
## nope, sadly this is not quite clean json translation, due to repeated element structure
datacite_list <-
httr::GET("https://doi.org/10.5281/zenodo.573741", 
    httr::add_headers(Accept="application/vnd.datacite.datacite+xml")) %>% 
  httr::content(type="application/xml") %>% 
  xml2::as_list() %>%  
  toJSON(pretty = TRUE, auto_unbox=TRUE) #%>%
#  fromJSON()

## Read tidy version instead
```



```{r}
datacite_ex <- "https://raw.githubusercontent.com/codemeta/codemetar/master/inst/examples/datacite-xml.json"
cat(readLines(datacite_ex), sep="\n")
```

Note this example uses a JSON-ified representation of DataCite's internal schema, which is XML-based.  So far, this is just plain JSON, with no context.  We will use the `codemetar::crosswalk` function to translate this into codemeta representation. This function simply creates a context file for the input data, based on the crosswalk table, and then performs the JSON-LD Expansion algorithm followed by the JSON-LD Compaction algorithm into the codemeta context, in just the same manner as illustrated above.  


```{r}
datacite_meta <- jsonlite::read_json(datacite_ex)
dc <- crosswalk(datacite_meta,"DataCite")
dc
```



### Comparison to native schema.org translation:

DataCite actually returns data directly in JSON-LD format using exclusively the schema.org context.  We can query that data directly:

```{r}
resp <- httr::GET("https://doi.org/10.5281/zenodo.573741", httr::add_headers(Accept="application/vnd.schemaorg.ld+json"))
datacite_jsonld <- httr::content(resp, type="application/json")
```

This time we have no need to invoke the crosswalk context, since the data is already in schema.org context (which codemeta also uses):

```{r}
datacite_cm <- 
  datacite_jsonld %>% 
  toJSON(pretty = TRUE, auto_unbox = TRUE) %>%
  jsonld_expand() %>% 
  jsonld_compact(context = "https://raw.githubusercontent.com/codemeta/codemeta/master/codemeta.jsonld") 
datacite_cm
```


This is very close to the codemeta document we got by translating the DataCite XML using the crosswalk table.  

### Translating between arbitrary columns in the crosswalk

```{r}
crosswalk(datacite_meta, "DataCite", "Zenodo") %>% 
drop_context() # show only content
```

This data should be now use valid Zenodo terms (e.g. using `creators` for `schema:author`).  Note that we also see explicitly the context that `codemeta::crosswalk` produced as `zenodo_context`, since we passed this information as a json file and not a URL.  This provides a nice illustration of what the crosswalk is returning when asked for a context of a given column.  

Note that data that many of the fields could not be directly crosswalked into Zenodo terms, because (at least according to the crosswalk table) they have no analog in Zenodo, such as `schema:dateCreated`.  Instead of dropping this data, the JSON-LD has retained the information using the original prefix `schema:`, indicating that the term is part of the `schema.org` context but not recognized in the context of Zenodo.  

Note this also happens if properties do not have a 1:1 map, since JSON-LD doesn't provide a convenient way to map two separate properties like `givenName`, `familyName` into a single property, `name` either.  JSON-LD will also refuse to map a term that has a potentially different type in the new context (since type coercion can also lead to data loss).  In this way, compaction is very conservative.  





